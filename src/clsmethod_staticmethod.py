#coding=utf8

class A():
    def m1(self, n): #类A的实例方法
        print ("self:",self) 
        
    @classmethod
    def m2(cls,n):#类方法
        print ("cls:",cls)
        
    @staticmethod #静态方法，通常会和私有方法配合使用_private
    def m3(n):
        print "静态方法m3:",n
    
    def m4(self):
        self.m2(1)
    


a = A() #生成类A的实例对象a
# A.m1(1) #会报错，因为m1是实例方法(需要绑定一个实例对象)，因此需要显式的传递一个实例对象进去，如A.m1(a,1).注：python3可以是任意对象
a.m1(1) #调用实例对象，因为m1方法的第一个参数是self，因此Python会隐式的将实例对象a传给m1方法，等价于A.m1(a,1)

A.m2(1) #因为m2是类方法,参数cls默认绑定当前类A，因此能通过类来调用
a.m2(1) #类的实例也可以调用类方法,因为python可以通过实例对象a找到它所属的类A，找到后自动绑定到参数cls,
        #因此我们可以在类或者子类中用self.m2()来调用类方法或者静态方法,比如m4
a.m4()

A.m3(1) #静态方法和单独在外面定义的普通函数没区别，跟类和实例都没有绑定关系，且不加实例self或类cls参数，放在类中是仅为该类服务
        #通过类和实例来调用都是访问同一个内存地址中的对象
a.m3(1)

'''注：访问类方法和静态方法推荐还是用类来调用，这样省去了实例化对象的开销成本(占用内存)'''


'''静态方法的使用场景：

如果在方法中不需要访问任何实例方法和属性，纯粹地通过传入参数并返回数据的功能性方法，那么它就适合用静态方法来定义，
它节省了实例化对象的开销成本，往往这种方法放在类外面的模块层作为一个函数存在也是没问题的，而放在类中，仅为这个类服务。

   类方法的使用场景：
如果希望在方法裡面调用静态类，那么把方法定义成类方法是合适的，因为要是定义成静态方法，那么你就要显示地引用类A，这对继承来说可不是一件好事情。

'''
